{"version":3,"sources":["../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","../../../../node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../../src/app/actions/auth.ts"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","\"use server\";\n\nimport { prisma } from \"@/lib/prisma\";\nimport { hashPassword } from \"@/lib/auth\";\nimport { revalidatePath } from \"next/cache\";\n\ninterface RegisterResult {\n    success: boolean;\n    message: string;\n}\n\nexport async function registerUser(formData: FormData): Promise<RegisterResult> {\n    const username = formData.get(\"username\") as string;\n    const password = formData.get(\"password\") as string;\n    const name = formData.get(\"name\") as string;\n    const regions = formData.getAll(\"regions\") as string[];\n\n    if (!username || !password || !name) {\n        return { success: false, message: \"All fields are required\" };\n    }\n\n    try {\n        // Check if username exists\n        const existing = await prisma.user.findUnique({\n            where: { username },\n        });\n\n        if (existing) {\n            return { success: false, message: \"Username already exists\" };\n        }\n\n        // Hash password\n        const hashedPassword = await hashPassword(password);\n\n        // Create user\n        await prisma.user.create({\n            data: {\n                username,\n                password: hashedPassword,\n                name,\n                role: \"supervisor\",\n                region: regions.join(\",\"),\n            },\n        });\n\n        revalidatePath(\"/login\");\n        return { success: true, message: \"Registration successful\" };\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        return { success: false, message: \"Registration failed\" };\n    }\n}\n\nexport async function updateUserProfile(\n    oldUsername: string,\n    formData: FormData\n): Promise<RegisterResult> {\n    const newUsername = formData.get(\"username\") as string;\n    const newName = formData.get(\"name\") as string;\n    const newPassword = formData.get(\"password\") as string;\n\n    try {\n        // Check if new username is taken by someone else\n        if (newUsername !== oldUsername) {\n            const existing = await prisma.user.findUnique({\n                where: { username: newUsername },\n            });\n            if (existing) {\n                return { success: false, message: \"Username already taken\" };\n            }\n        }\n\n        const updateData: { username?: string; name?: string; password?: string } = {};\n\n        if (newUsername !== oldUsername) {\n            updateData.username = newUsername;\n        }\n\n        if (newName) {\n            updateData.name = newName;\n        }\n\n        if (newPassword) {\n            updateData.password = await hashPassword(newPassword);\n        }\n\n        await prisma.user.update({\n            where: { username: oldUsername },\n            data: updateData,\n        });\n\n        return { success: true, message: \"Profile updated successfully\" };\n    } catch (error) {\n        console.error(\"Update error:\", error);\n        return { success: false, message: \"Update failed\" };\n    }\n}\n"],"names":["registerServerReference","ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"6CAAoD,OAAA,cAAA,CAAA,EAAA,aAAA,oCAC3CA,0BAAAA,qCAAAA,EAAAA,uBAAuB,YAAQ,CAAA,CAAA,IAAA,iCCEjC,SAASC,EAAyBC,CAAc,EACrD,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQE,MAAM,CAAED,IAAK,CACvC,IAAME,EAASH,CAAO,CAACC,EAAE,CACzB,GAAsB,YAAlB,AAA8B,OAAvBE,EACT,MAAM,OAAA,cAEL,CAFK,AAAIC,MACR,CAAC,2DAA2D,EAAE,OAAOD,EAAO;AAAA,oEAAuE,CAAC,EADhJ,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EAEJ,CACF,0EATgBJ,2BAAAA,qCAAAA,8CCDhB,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,MACA,EAAA,EAAA,CAAA,CAAA,OAOO,eAAe,EAAa,CAAkB,EACjD,IAAM,EAAW,EAAS,GAAG,CAAC,YACxB,EAAW,EAAS,GAAG,CAAC,YACxB,EAAO,EAAS,GAAG,CAAC,QACpB,EAAU,EAAS,MAAM,CAAC,WAEhC,GAAI,CAAC,GAAY,CAAC,GAAY,CAAC,EAC3B,IADiC,EAC1B,CAAE,SAAS,EAAO,QAAS,yBAA0B,EAGhE,GAAI,CAMA,GAJiB,CAIb,KAJmB,EAAA,GAIT,GAJe,CAAC,IAAI,CAAC,UAAU,CAAC,CAC1C,MAAO,UAAE,CAAS,CACtB,GAGI,MAAO,CAAE,QAAS,GAAO,QAAS,yBAA0B,EAIhE,IAAM,EAAiB,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,GAc1C,OAXA,MAAM,EAAA,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CACrB,KAAM,UACF,EACA,SAAU,OACV,EACA,KAAM,aACN,OAAQ,EAAQ,IAAI,CAAC,IACzB,CACJ,GAEA,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,UACR,CAAE,QAAS,GAAM,QAAS,yBAA0B,CAC/D,CAAE,MAAO,EAAO,CAEZ,OADA,QAAQ,KAAK,CAAC,sBAAuB,GAC9B,CAAE,SAAS,EAAO,QAAS,qBAAsB,CAC5D,CACJ,CAEO,eAAe,EAClB,CAAmB,CACnB,CAAkB,EAElB,IAAM,EAAc,EAAS,GAAG,CAAC,YAC3B,EAAU,EAAS,GAAG,CAAC,QACvB,EAAc,EAAS,GAAG,CAAC,YAEjC,GAAI,CAEA,GAAI,IAAgB,GACC,MAAM,EAAA,EADM,IACA,CAAC,IAAI,CAAC,UAAU,CAAC,CAC1C,MAAO,CAAE,SAAU,CAAY,CACnC,GAEI,MAAO,CAAE,SAAS,EAAO,QAAS,wBAAyB,EAInE,IAAM,EAAsE,CAAC,EAmB7E,OAjBI,IAAgB,IAChB,EAAW,OADkB,CACV,CAAG,CAAA,EAGtB,IACA,EAAW,GADF,CACM,CAAG,CAAA,EAGlB,IACA,EAAW,OADE,CACM,CAAG,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAA,EAG7C,MAAM,EAAA,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CACrB,MAAO,CAAE,SAAU,CAAY,EAC/B,KAAM,CACV,GAEO,CAAE,SAAS,EAAM,QAAS,8BAA+B,CACpE,CAAE,MAAO,EAAO,CAEZ,OADA,QAAQ,KAAK,CAAC,gBAAiB,GACxB,CAAE,SAAS,EAAO,QAAS,eAAgB,CACtD,CACJ,0CArFsB,EA0CA,IA1CA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MA0CA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA","ignoreList":[0,1]}